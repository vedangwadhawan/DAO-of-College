// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract Project {
    
    // Struct to store proposal details
    struct Proposal {
        uint256 id;
        string title;
        string description;
        uint256 budgetRequired;
        address payable proposer;
        uint256 voteCount;
        uint256 deadline;
        bool executed;
        bool exists;
        mapping(address => bool) voters;
    }
    
    // State variables
    address public admin;
    uint256 public proposalCount;
    uint256 public votingPeriod = 7 days;
    mapping(uint256 => Proposal) public proposals;
    mapping(address => bool) public members;
    uint256 public memberCount;
    
    // Events
    event MemberAdded(address member);
    event ProposalCreated(uint256 proposalId, string title, uint256 budget, address proposer);
    event Voted(uint256 proposalId, address voter);
    event ProposalExecuted(uint256 proposalId, uint256 amount, address recipient);
    
    // Modifiers
    modifier onlyAdmin() {
        require(msg.sender == admin, "Only admin can perform this action");
        _;
    }
    
    modifier onlyMember() {
        require(members[msg.sender], "Only members can perform this action");
        _;
    }
    
    constructor() {
        admin = msg.sender;
        members[msg.sender] = true;
        memberCount = 1;
    }
    
    // Function to add members to the DAO
    function addMember(address _member) external onlyAdmin {
        require(!members[_member], "Already a member");
        members[_member] = true;
        memberCount++;
        emit MemberAdded(_member);
    }
    
    // Core Function 1: Submit a proposal
    function submitProposal(
        string memory _title,
        string memory _description,
        uint256 _budgetRequired
    ) external onlyMember returns (uint256) {
        require(bytes(_title).length > 0, "Title cannot be empty");
        require(_budgetRequired > 0, "Budget must be greater than 0");
        
        proposalCount++;
        Proposal storage newProposal = proposals[proposalCount];
        newProposal.id = proposalCount;
        newProposal.title = _title;
        newProposal.description = _description;
        newProposal.budgetRequired = _budgetRequired;
        newProposal.proposer = payable(msg.sender);
        newProposal.voteCount = 0;
        newProposal.deadline = block.timestamp + votingPeriod;
        newProposal.executed = false;
        newProposal.exists = true;
        
        emit ProposalCreated(proposalCount, _title, _budgetRequired, msg.sender);
        return proposalCount;
    }
    
    // Core Function 2: Vote on a proposal (votes are locked)
    function voteOnProposal(uint256 _proposalId) external onlyMember {
        Proposal storage proposal = proposals[_proposalId];
        
        require(proposal.exists, "Proposal does not exist");
        require(block.timestamp < proposal.deadline, "Voting period has ended");
        require(!proposal.executed, "Proposal already executed");
        require(!proposal.voters[msg.sender], "Already voted on this proposal");
        
        proposal.voters[msg.sender] = true;
        proposal.voteCount++;
        
        emit Voted(_proposalId, msg.sender);
    }
    
    // Core Function 3: Execute proposal and release funds
    function executeProposal(uint256 _proposalId) external {
        Proposal storage proposal = proposals[_proposalId];
        
        require(proposal.exists, "Proposal does not exist");
        require(block.timestamp >= proposal.deadline, "Voting period not ended");
        require(!proposal.executed, "Proposal already executed");
        require(address(this).balance >= proposal.budgetRequired, "Insufficient contract balance");
        
        // Check if proposal passed (more than 50% of members voted yes)
        uint256 quorum = (memberCount * 50) / 100;
        require(proposal.voteCount > quorum, "Proposal did not reach quorum");
        
        proposal.executed = true;
        proposal.proposer.transfer(proposal.budgetRequired);
        
        emit ProposalExecuted(_proposalId, proposal.budgetRequired, proposal.proposer);
    }
    
    // Helper function to fund the contract
    function fundDAO() external payable {
        require(msg.value > 0, "Must send some ether");
    }
    
    // Helper function to check if an address has voted on a proposal
    function hasVoted(uint256 _proposalId, address _voter) external view returns (bool) {
        return proposals[_proposalId].voters[_voter];
    }
    
    // Helper function to get proposal details
    function getProposal(uint256 _proposalId) external view returns (
        string memory title,
        string memory description,
        uint256 budgetRequired,
        address proposer,
        uint256 voteCount,
        uint256 deadline,
        bool executed
    ) {
        Proposal storage proposal = proposals[_proposalId];
        require(proposal.exists, "Proposal does not exist");
        
        return (
            proposal.title,
            proposal.description,
            proposal.budgetRequired,
            proposal.proposer,
            proposal.voteCount,
            proposal.deadline,
            proposal.executed
        );
    }
    
    // Get contract balance
    function getDAOBalance() external view returns (uint256) {
        return address(this).balance;
    }
    
    // Fallback function to receive ether
    receive() external payable {}
}
